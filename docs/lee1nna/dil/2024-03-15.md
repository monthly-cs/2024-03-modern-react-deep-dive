# 2024-03-15 (2주차 5일)

날짜 : 2024-03-15
범위 : 208 ~ 240p

- useMemo
    - 비용이 큰 연산에 대한 결과를 저장(메모이제이션), 저장된 값을 반환하는 훅
    - 첫번째 인수로는 값을 반환하는 생성 함수, 두 번째 인수로는 해당 함수가 의존하는 값의 배열을 전달
    - 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 이전에 기억해 둔 값을 반환 (최적화!)
    - 메모이제이션은 값 뿐만 아닌 컴포넌트도 가능 (그러나 컴포넌트는 React.memo를 쓰는 것이 더 현명)
- useCallback
    - useMemo와 동일한 역할이나 값이 아닌 콜백 함수를 반환 (특정 함수를 재활용하겠다는 의미)
    - 익명 함수가 아닌 기명 함수를 넘겨 줄 경우 메모리 탭에서 디버깅이 용이해짐
- useRef
    - 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태 값을 저장
    - 값이 변해도 렌더링을 하지 않음
    - 일반적인 사용은 DOM에 사용하고 싶을 때 사용
- useContext
    - 명시적인 props의 전달 없이도 선언한 하위 컴포넌트에서 자유롭게 원하는 값 사용 가능
    - 여러개의 Provider가 있을 경우에 가장 가까운 Provider의 값을 가져옴
    - Provider에 의존성을 가지고 있는 셈이기 때문에 컴포넌트 재활용이 어려워짐을 염두해두며 사용해야 함
    - 상태 관리를 위한 리액트 API X => 상태를 주입해주는 API일 뿐
- useReducer
    - useState의 심화 버전으로 더 복잡한 상태값을 미리 정의해 놓음
    - 복잡한 형태의 state를 사전에 정의된 dispatcher로 수정할 수 있게 만들어 줌 => state 값에 대한 접근은 컴포넌트에서만 가능
    - 업데이트 하는 방법에 대한 상세 정의는 컴포넌트 밖에다두고 미리 정의해둔 dispatcher로만 상태 업데이트를 제한
    - state를 사용하는 로직과 관리하는 비즈니스 로직을 분리 할 수 있어 state 관리가 쉬워짐
- useImperativeHandle
    - 선행지식 : forwardRef
        - ref를 props를 전달하는 데 있어 일관성을 제공하기 위해 탄생
        - 완전한 네이밍의 자유가 주어진 props보다 forwardRef를 사용해서 확실히 ref 전달을 알림
    - 부모에게 넘겨받은 ref를 원하는대로 수정 가능한 훅
- useLayoutEffect
    - useEffect와 형태와 사용 예제가 동일함
    - 모든 DOM의 변경 후에 useLayoutEffect의 콜백 함수 실행이 동기적으로 발생
    - DOM변경이 렌더링이지 브라우저에 실제로 변경사항이 반영되는 시점을 의미하는 것은 아님
        - 1. 리액트가 DOM 업데이트
        - 2. useLayoutEffect 실행
        - 3. 브라우저에 변경 사항 반영
        - 4. useEffect 실행
    - useEffect보다 먼저 실행되어 DOM은 계산 됐지만 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용
- useDebugValue
    - 프로덕션 웹서비스에 사용하는 훅은 아님
    - 사용자 정의 훅 내부에 내용에 대한 정보를 남길 수 있는 훅
    - 훅 내부에서만 실행 가능
- 훅의 규칭
    - 실행순서를 보장 받을 수 있는 컴포넌트 최상위에서만 훅을 호출해야 한다.
    - 반복문이나 중첩된 함수에서 훅 호출 불가능 (훅 내부에서 반복문이나 중첩문을 사용할 순 있다.)
