# 2024-03-14 (2주차 4일)

날짜 : 2024-03-14
범위 : 189 ~ 208p

- useState
    - 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅
    - 초기값에 아무런 값을 넣어주지 않으면 undefined로 초기화
    - 클로저에 의존해 구현되어 있을 것이라 짐작 (함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 때문)
- 게으른 초기화(lazy initialization)
    - useState에 변수 대신 함수를 넘기는 것
    - useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용
    - 오로지 useState가 처음 만들어질 때만 사용
    - localStorage나 sesstionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근 같은 무거운 연산에 사용
- useEffect
    - 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만듦
    - 첫번째 인수로 실행 할 부수효과가 포함된 함수, 두번째 인수로는 의존성 배열 전달
    - 함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행하는데 useEffect 역시 렌더링 할 때마다 의존성에 있는 값을 보면서
    의존성 값이 이전과 다른게 하나라도 있으면 부수 효과를 실행하는 평범한 함수임
- 클린업 함수
    - 이벤트로 등록하고 지울 때 주로 사용
    - 새로운 값을 기반으로 렌더링 뒤에 실행되긴 하나, 이전 state를 참조해 실행됨.
    - 언마운트 함수라기 보다 컴포넌트가 리렌더링 됐을 때 의존성 변화가 있으면 이전의 값을 기준으로 실행되는 청소 함수
- 의존성 배열
    - 빈 배열 일 경우 : 비교할 의존성이 없다고 판단해 최초 렌더링
    - 아무런 값도 안넘겨줄 경우 : 렌더링이 발생할 때마다 실행
        => useEffect 안써도 되는게 아닌가? useEffect는 클라이언트 사이드에서 실행되는 것 보장, 함수 내부에서 직접 실행은
        컴포넌트 렌더링 도중에 실행되어 렌더링을 방해함
    - effect는 컴포넌트의 부수효과를 의미한다는 것을 명심
    - 값이 있을 경우 : 이전 값과 현재 값의 Object.is를 기반으로 하는 얕은 비교 수행