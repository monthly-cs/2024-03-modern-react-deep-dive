# 모던 리액트 딥다이브 week2 발표자료
# 2024-03-17 Presentation

|주차|공부 범위|날짜|발표 범위|
|------|---|---|---|
| 2주차 |3장, 5장|2024-03-15|3장(189-251p)|



# 03장 리액트 훅 깊게 살펴보기

# 리액트의 모든 훅 파헤치기
## 훅의 장점
- 리액트의 핵심적인 기능을 함수에서도 가능하게 만든다.
- 클래스 컴포넌트 보다 간결하게 작성할 수 있다.

## useState 
함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅.

useStae 훅의 결과값은 어떻게 함수가 실행되도 그 값을 유지하고 있을까?
-> 클로저를 이용. 실제 리액트 코드에서는 useReducer를 이용.

어떤 함수(state) 내부에 선언된 함수가 함수의 실행이 종료된 이후에도 지역변수인 <br>
state를 계속 참조할 수 있다는 것을 의미한다.

### 클로저(앞의 1장에서 언급)
> 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법.

### 게으른 초기화
- useState의 인수로 변수 대신 함수를 넘기는 것.
- state가 처음 만들어질 때만 사용됨. 이후 리렌더링의 경우 함수 실행 무시.
- 초깃값이 복접하거나 무거운 연산을 포함하고 있을 때 사용해야 함.
- ex. localStorage, sessionStorage, map, filter, find 등.

## useEffect

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘.
- 첫번째 인수 실행할 부수효과가 포함된 함수
- 두번째 인수 의존성 배열을 전달.
- 의존성 배열이 변경될 때 마다 콜백을 실행. -> 어떻게 변경되는 것을 인지할까?

함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다.  
렌더링 시 마다 고유의 state와 props 값을 가지고 있다. 
useEffect는 렌더링할 때마다 의존성에 있는 값을 보면서 의존성의 값이 이전과 다른 게 하나라도 있으면 
부수 효과를 실행하는 평범한 함수라고 볼 수 있다.

### useEffect의 클린 업 함수
이벤트를 등록하고 지울 때 사용.
이전 state를 참조해 실행된다.
함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행. 값 새로고침 X.

### 클린 업 함수에서 지워야 하는 이유
이전의 클린 업 함수가 존재한다면 그 클린 업 함수를 실행한 뒤에 콜백을 실행.
-> 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가.

### useEffect 구현
핵심: 의존성 배열의 이전 값 & 얕은 비교.
이전 의존성 배열과 현재 의존성 배열의 값에 하나라도 변경사항이 있다면 callback으로 선언한 부수효과를 실행.

#### useEffect 사용 시 주의할 점.

1. 주석을 사용하여 의존성 배열 명시하지 않고자 하는 경우 : //eslint-disable-line react-hooks/exhaustive-deps
: useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행돼야 하는 훅이기 때문에 최대한 자제하여 사용하기.

2. 첫번째 인수에 함수명 부여하기
   : useEffect 코드가 복잡하고 많아질 수록 무슨 일을 하는지 알고자 함의 이유.
3. 거대한  useEffect 만들지 말기
   : 렌더링 시, 의존성이 변경될 때마다 부수효과를 실행. -> 크기가 커질수록 애플리케이션 성능에 악영향을 미침.
4. 불필요한 외부함수 만들지 말기
   : 불필요한 코드, 가독성 떨어짐 이슈발생 -> useEffect 내에서 사용할 부수 효과라면, 내부에서 만들어 정의해서 사용하기.


## useMemo 구현

- 비용이 큰 연산에 대한 결과를 저장해두고, 이 저장된 값을 반환하는 훅.
- 최적화에 유리한 훅
- '값 과 컴포넌트'의 메모이제이션.


## useCallback 구현

-인수로 넘겨받은 콜백 자체를 기억. : 특정함수를 "재사용".
- '함수'의 메모이제이션
- 첫번째 인수로 함수, 두번째 인수로 의존성 배열을 집어넣는다 -> useMemo와 마찬가지로 함수를 재생성하지 않는다.
- 의존성이 변경됐을 때만 함수가 재생성하려면? -> useCallback 추가하여 사용.
- useMemo로 구현이 가능하지만 불필요하게 코드가 길어지고 혼동 불러일으킬 수 있음.

=> useMemo와 useCallback의 차이점

|useMemo|메모이제이션: 값(변수)|
|------|---|
| useCallback |메모이제이션: 함수|


## useRef
- useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태 값을 저장.
- 반환 값인 객체 내부에 있는 current로 값에 접근 또는 변경 가능.
- 컴포넌트가 렌더링 될 때만 생성: 메모리에 불필요한 값을 줄여줌.
- 컴포넌트 인스턴스가 여러 개라도 각각 별개의 값을 바라봄.

사진 갤러리를 만들어보면서 useRef를 사용해서 count값을 관리해본다면??


## useContext

#### 리액트의 Context란?
- props 내려주기(부모의 데이터를 자식도 사용하고 싶을 때 생기는 이슈)를 극복하기 위해 등장한 개념.
- props 전달 없어도 선언한 하위 컴포넌트 모두에서 자유롭게 원하는 값 사용 가능.

#### 이러한 Context를 함수 컴포넌트에서 사용할 수 있게 하는 useContext

여러 개의 Provider 중, 가장 가까운 Provider를 가져와서 사용한다.

#### 콘텍스트가 존재하지 않아 예상치 못한 에러가 발생하는 경우.

##### 해당 에러 방지하기 위해 useContext 내부에서 해당 콘텍스트가 존재하는 환경인지 확인 필요
: 다수의 Provider와 useContext를 사용할 때 별도 함수로 감싸서 사용하기. (타입추론, 상위 Provider가 없는 경우 에러 찾기 수월함.)

#### useContext 사용 시 주의할 점.
- 함수 내부에서 사용 시, 컴포넌트 재활용이 어렵다.
- Provider와의 의존성 방지: 컴포넌트를 최대한 작게, 재사용되지 않을 만한 컴포넌트에서 사용.
- 주입된 상태를 사용할 수 있을 뿐, 그 자체로 렌더링 최적화에 도움되지 않음.


## useReducer

- useState의 심화버전: 복잡한 상태 값을 미리 정의해 놓은 시나리오에 따라 '관리'할 수 있다. ->state를 사용하는 로직 & 관리하는 비즈니스 로직을 분리하여 쉽게 관리 가능하다.  
- useState와는 다르게, 3개의 인수를 필요로 한다.(reducer, initialState, init)
  > reducer: useReducer의 기본 action을 정의하는 함수./ 첫번째 인수
  > initialState: 초깃값 / 두번째 인수.
  > init: 초깃값을 지연해서 생성시키고 싶을 때 사용하는 함수. (필수 값X.)
## useImperativeHandle

### forwardRef
: useRef에서 반환된 객체인, ref를 전달하는데 있어서 일관성, 예측가능성을 제공하기 위해 만들어짐.

### useImperativeHandle 훅이란?

- 부모에게서 넘겨받은 ref를 원하는대로 수정이 가능함./ 원하는 값이나 액션 정의 가능.
- 자식 컴포넌트에서 새롭게 설정한 객체의 키와 값에 대해서도 접근 가능.

## useLayoutEffect

- useEffect보다 먼저 실행됨.(브라우저 변경 사항 반영되기 전 실행.)
- DOM은 계산됐지만 화면에 반영되기 전에 하고 싶은 작업이 있을 때 사용.// 더 자연스러운 사용자 경험 제공이 가능해짐.

## useDebugValue

- 사용자 정의 훅 내부의 내용에 대한 정보를 남길 수 있는 훅.
- 오직 다른 훅 내부에서만 실행할 수 있음.
- 공통 훅을 제공하는 라이브러리나 대규모 웹 애플리케이선에서 디버깅 관련 정보를 제공하고 싶을 때 유용하게 사용가능.

## Rules-of-Hooks
- 최상위에서만 훅을 호출해야 한다. 반복/조건문/ 중첩된 함수 내에서 훅 실행 불가: 컴포넌트 렌더링이 동일한 순서로 훅이 호출되는 것 보장가능.
- 훅을 호출할 수 있는 것은 리액트 함수 컴포넌트. 사용자 정의 훅의 두가지 경우 뿐임. 일반 자바스크립트에서 사용불가.

================================================================================================================================

## 사용자 정의 훅 & 고차 컴포넌트

리액트에서 재사용할 수 있는 로직을 관리하는데 어떤 방법을 써야 할까?

### 사용자 정의 훅

- 서로 다른 컴포넌트 내에서 같은 로직을 공유하고자 할 때 주로 사용됨.(리액트에서만 사용가능한 방식.)
- use~ 이름으로 설정. : react-hooks/rules-of-hooks의 도움을 받을 수 있음.

### 고차 컴포넌트

- with~로 시작하는 이름 사용. (리액트 커뮤키티 관습)
- 컴포넌트 자체의 로직을 재사용하기 위한 방법.
- 자바스크립트 환경에서 사용가능: 고차함수의 일종으로 자바스크립트의 일급객체,함수의 특징을 이용함.
- 컴포넌트의 결과물에 영향을 미칠 수 있는 다른 공통된 작업 처리가능.


#### React.memo

- props의 변화가 없음에도 컴포넌트의 렌더링을 방지하기 위해 만들어진 리액트의 고차 컴포넌트.
- 렌더링 전 props와 비교해 이전과 같다면 렌더링 생략 + 이전에 기억해둔(memoization) 컴포넌트 반환.


#### 고차함수 만들어보기

- 고차함수?: '함수'를 인수로 받거나 결과로 반환하는 함수.
- 대표적인 고차함수: Array.prototypr.map()
- 사용 가치: 설정해 놓은 조건에 따라 다른 결과를 반환할 때.
- 예) 사용자 인증 정보에 따라,
  > 인증된 사용자 -> 개인화된 컴포넌트 <br>
  > 인증X 사용자 -> 공통 컴포넌트

#### 고차함수 사용 시 주의사항

- 부수효과 최소화
  : 고차함수는 컴포넌트를 인수로 받으므로, 언제 props가 수정될 지 모른다는 우려를 가지고 개발하는 불편함을 줄이기 위해 컴포넌트의 props 변경 X.
- 여러 개의 고차 컴포넌트로 컴포넌트를 감쌀 경우 복잡성이 커진다.
  : 고차 컴포넌트가 증가할 수록 어떤 결과를 만들어낼지 예측 가능성을 높이기 위해 최소한으로 사용.

### 사용자 정의 훅 vs 고차 컴포넌트 사용 방법

#### 사용자 정의 훅
> 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공 or 특정한 훅의 작동을 취하게 하고 싶은 경우 사용.
#### 고차 컴포넌트
> 함수 컴포넌트의 반환 값, 렌더링의 결과물에도 영향을 미치는 공통 로직인 경우 사용.
