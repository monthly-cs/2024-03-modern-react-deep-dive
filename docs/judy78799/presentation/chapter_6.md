# 모던 리액트 딥다이브 week6
# Presentation

|주차|발표범위|날짜|공부범위|
|------|---|---|---|
| 6주차 |11장|2024-04-13|655-774p|

# 발표자료 제작
# 11장: Next.js 13과 리액트 18

# 11장에서 주로 다루게 될 내용

- Next.js 13에서 어떤 변화가 있었는지 알아보자.
- 기존 Next.js를 어떻게 변경하고 개선해 나갈 수 있는지 살펴본다.

## 1부: /app 디렉터리 등장

![image](https://github.com/monthly-cs/2024-03-modern-react-deep-dive/assets/116958681/6b721aa5-abd8-48e7-9b1a-756394908313)

이전 Next.js 12버전까지는 _app으로 페이지 공통 레이아웃 유지했음.
하지만,
- 페이지 공통 레이아웃 방식이 _app에서 밖에 할 수 없어 제한적임.
- 각 페이지 별로 서로 다른 레이아웃을 유지할 수 있는 여지가 부족함.

이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app레이아웃임.
이 레이아웃을 app 디렉터리에서 어떻게 구현하는지 살펴보자.

### 라우팅

Next.js 13에서 라우팅과 페이지를 정의하는 방식이 어떻게 바뀌었는지 살펴보자.

#### 라우팅을 정의하는 법

기본적으로  Next.js의 라우팅은 파일 시스템을 기반으로 하고 있음.
Next.js 13 app: /app/a/b는 /a/b로 변환되며, 파일명(app)은 무시된다. 폴더명까지만 주소로 변환된다.

Next.js 13 부터는 app 디렉터리 내부의 폴더명이 라우팅이되며,
이 폴더에 포함될 수 있는 파일명(예약어)은 몇가지로 제한돼 있다.

#### layout.js

- 페이지의 기본적인 레이아웃을 구성하는 요소.
- 루트에는 단 하나의 layout을 만들 수 있다.
- 웹 페이지를 만드는 데 필요한 공통적인 내용(html, head 등)을 다루는 곳이다.
- 많은 개발자들을 헷갈리게 만들었던 _app, _document를 '하나로' 대체할 수 있다.
  > _app: 페이지에 적용할 공통 레이아웃.
  > _document: 공통적으로 활용할 head나 body 태그 안에 들어갈 내용.
- 하나의 애플리케이션에서 레이아웃을 더욱 유연하게 구성할 수 있게되었다.
- 주소별 공통 UI를 포함할 수 있을 뿐 아니라. _app과 _document를 대신해 웹페이지를 시작하는데 필요한 공통 코드를 삽입할 수 있다.
- 공통 코드는 오로지 자신과 자식 라우팅에만 미치게 된다.

##### layout의 규칙
- 무조건 layout.{js|jsx|ts|tsx}로 사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
- children을 props로 받아서 렌더링해야 한다. 레이아웃 이므로 그려야 할 컴포넌트를 외부에서 주입받고 그려야 한다.
- layout 내부에 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
- layout 내부에서도 API 요청과 같은 비동기 작업을 수행할 수 있다.

#### page.js
- 이전까지 Next.js에서 일반적으로 다뤘던 페이지를 의미한다.
- 앞에서 구성했던 layout을 기반으로 위와 같은 리액트 컴포넌트를 노출하게 된다.
- page는 params와 searchParams라는 props를 받는다.

##### page의 규칙
- 무조건 page.{js|jsx|ts|tsx}로 사용해야 하며 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
- page 내부에 반드시 export default로 내보내는 컴포넌트가 있어야 한다.

#### error.js
- 해당 라우팅 영역에서 사용되는 고통 에러 컴포넌트이다.
- 사용할 경우 특정 라우팅 별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.
- 에러 정보를 담고 있는 error:Error 객체와 에러 바운더리를 초기화 할 reset: () => void를 props로 받는다.
- 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트도 클라이언트 컴포넌트여야 한다.
- 같은 수준의 layout 에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않는다.

##### if) Layout에서 발생한 에러를 처리하고 싶다면 상위 컴포넌트의 error를 사용 or, app의 루트 에러 처리를 담당하는 app/global-error.js 페이지를 생성하자.

#### not-found.js
- 특정 라우팅 하위의 주소를 찾을 수 없는 404페이지를 렌더링할 때 사용된다.
- 전체 애플리케이션에서 404를 노출하고 싶다면 app/not-found.js를 생성해 사용하면 된다.
- 서버 컴포넌트로 구성하면 된다.
  
#### loading.js
- 리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.
- "use client" 지시자를 사용해 클라이언트에서 렌더링되게 할 수 있다.

#### route.js
- /api에 대해 파일명 라우팅이 없어진 대신, 디렉터리가 라우팅 주소를 담당하며 파일명은 route.js로 통일되었다.
- route.ts 파일 내부에 REST API의 get,post와 같은 메서드명을 예약어로 선언해두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다.
- app/api 외에 다른 곳에서 선언해도 작동한다.
- request, context 파라미터를 받을 수 있다.
- 라우팅 명칭에 자유도가 생긴 대신, route.ts가 존재하는 폴더 내부에는 page.tsx가 존재할 수 없다.

```
//route.ts + page.tsx 에러메시지
error - [next app] app
An issue occured while preparing your Next.js app
Conflicting route at /internal-api/hello
```

## 2부: 리액트 서버 컴포넌트
- 리액트 서버 컴포넌트: 리액트 18에서 새로 도입된 개념.
  
### 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.
  
### 서버 컴포넌트란?

![image](https://github.com/monthly-cs/2024-03-modern-react-deep-dive/assets/116958681/8d9280ab-695b-4989-a37e-30db5e412776)

- 기존의 리액트 컴포넌트가 가지고 있던 한계점을 극복하기 위해 만들어졌다.
- 하나의 언어 하나의 프레임워크, 하나의 API오 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.
- 서버에서 할 수 있는 일은 서버가 처리, 나머지 작업은 클라이언트인 브라우저에서 실행된다.
- 리액트는 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류한다.
- 대신, 클라이언트 컴포넌트라는 것을 파일 맨 첫줄에 "use client" 라고 작성하여 명시적으로 선언한다.
- 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다. (반드시 에러가 발생한다.)

### 서버 사이드 렌더링과 서버 컴포넌트의 차이
- 서버사이드 렌더링: 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려준다. 그리고 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행한다.
정적인 HTML을 빠르게 내려주는데 초점을 두고 있다.
- 서버 사이드 렌더링과 서버 컴포넌트는 대체제가 아닌 상호보완하는 개념으로 보는 것이 좋다.
  > 리액트 팀은 미래에는 두 가지 기법이 모두 쓰일 수 있는는 가능성을 암시하고 있다.

### 리액트 서버 컴포넌트(RSC)는 어떻게 작동하는가?

1. 서버가 렌더링 요청을 받는다.
2. 서버에서 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize)한다.
  > 서버에서 렌더링 할 수 있는 것은 직렬화/ 클라이언트 컴포넌트로 내보낼 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타난다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다.

## 3부: Next.js에서의 리액트 서버 컴포넌트

Next.js 13 버전에 도입하면서 서버 컴포넌트를 도입했고, 이 서버 컴포넌트가 /app 디렉터리에 구현돼 있다.

#### 기본적인 서버 컴포넌트의 제약
- 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없다.
- 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.
- 루트 컴포넌트는 Next.js 에서 각 페이지에 존재하는 page.js 다. layout.js 도 마찬가지로 서버 컴포넌트로 작동한다.

```
//page.js
import ClientComponent from './ClientComponent'
import ServerComponent from './SeerverComponent'

//각 페이지는 기본으로 서버 컴포넌트로 작동한다.
export default function Page() {
  return(
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

Next.js 에서 서버 컴포넌트를 도입하면서 달라진 부분 몇가지를 살펴보자.

### 새로운 fetch의 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- 과거 Next.js 서버 사이드 렌더링과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticProps, getInitialProps 가 /app 디렉터리 내부에서 삭제되었다.
- 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.
- 서버에서 데이터를 직접 불러올 수 있게 됐다.
- 컴포넌트가 비동기적으로 작동하는 것도 가능해진다.

#### fetch API의 확장
- fetch API를 확장하여 서버 컴포넌트 트리 내에서 요청 중복을 방지했다.
  > SWR과 React Query와 비슷학, 해당 fetch 요청에 대한 내용을 서버에서는 렌더링이 한번 끝날 때까지 캐싱, 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.
  
### 정적 렌더링과 동적 렌더링

Next.js 13 에서는,

- **정적 라우팅**: 기본적으로 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해뒀다.
- **동적 라우팅**: 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경했다.
  > 캐싱하지 않겠다는 선언을 fetch에 하는 방법을 사용하거나,
  > 함수 내부에서 Next.js가 제공하는 next/headers, next/cookie 같은 헤더 정보와 쿠키 정보를 불러오는 함수를 사용한다.

if) 동적인 주소지만 특정 주소에 대해 캐싱하고 싶은 경우, generateStaticProps 함수(과거 Next.js의 getStaticPaths)를 사용하면 된다.

### 캐시와 mutating, 그리고 revalidating

#### 캐시와 갱신이 이뤄지는 과정
- 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
- 이 캐시된 초기 요청은 revalidate에 선언된 값 만큼 유지된다.
- 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
- Next.js는 캐시된 데이터를 보여준 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러온다.
- 4번의 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않다면 과거 데이터를 보여준다.

if) 이러한 캐시를 전체적으로 무효화하고 싶다면 router에 추가된 refresh 메서드로 router.refresh();를 사용하면 된다.
해당 작업은 브라우저나 리액트의 statee에는 영향을 미치지 않는다.


### 스트리밍을 활용한 점진적인 페이지 불러오기

기존의 서버 사이드 렌더링은 요쳥받은 페이지를 모두 렌더링해서 내려줄 때까지는 사용자에게 아무것도 보여줄 수 없으며, 사용자가 인터렉션할 수 없는 정적인 페이지이다.
스트리밍이란, 이를 해결하기 위해 HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내, 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여주는 방법이 가능하다.

#### 스트리밍을 활용하는 두 가지 방법

- 경로에 loading.tsx 배치: loading 파일을 배치하면 자동으로 Suspense가 배치된다.
- Suspense 배치: 좀 더 세분화된 제어를 위해 직접 리액트의 Suspense를 배치하는 것도 가능하다.

## 4부: 웹펙의 대항마, 터보팩의 등장(beta)

- 새롭게 뜨고 있는 라이브러리를 보면 다른 언어를 사용해 제공함으로써 자바스크립트 대비 월등히 뛰어난 성능을 보여준다는 것을 알 수 있다.
- 터보팩은 러스트 기반으로 작성되어 웹팩 대비 700배, Vite 대비 최대 10배 빠르다.

## 서버 액션(alpha)

- Next.js 13.4.0이 릴리스되면서 액션이라는 새로운 기능이 나타나게 되었다.
- API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능이다.
- 서버 컴포넌트와 다르게, 특정 함수 실행 그 자체만을 서버에서 수행할 수 있다는 장점이 있다.

### 서버 액션을 만들기 위해서는
1. 함수 내부 또는 파일 상단에 클라이언트 선언과 비슷하게 "use Server" 지시자를 선언해야 한다.
2. 함수는 반드시 async여야 한다.


서버 액션은 다음과 같은 형태로 선언할 수 있다.
```
async function serverAction() {
  "use server";
  //서버에서 바로 접근하는 코드
}

//이 파일 내부의 모든 내용이 서버 액션으로 간주된다.
'use server'

export async function myAction() {
  //...
  // 서버에 바로 접근하는 코드
}
```

### form의 action
<form />은 HTML에서 양식을 보낼 때 사용하는 태그로, action props를 추가하여 이 양식 데이터를 처리할 URL을 넘겨줄 수 있다.

서버 액션을 실행하면 클라이언트에서는 현재 라우트 주소와 ACTION_ID만 보내고 그 외에는 아무것도 실행하지 않는다.
서버에서는 요청받은 라우트 주소와 ACTION_ID를 바탕으로, 실행해야 할 내용을 찾고 이를 서버에서 직접 실행한다.
이를 위해 'use server'로 선언돼 있는 내용을 빌드 시점에 미리 클라이언트에서 분리시키고 서버로 옮김으로써, 서버에서만 실행되는 서버 액션을 만든 것을 확인할 수 있다.
또한 폼과 실제 노출하는 데이터가 연동돼 있을 때 더욱 효과적으로 사용할 수 있다.

### input의 submit과 image의 formAction
form.action과 마찬가지로 input type="submit 또는 input type="image"에 formAction props으로도 서버 액션을 추가할 수 있다.
### startTransition과의 연동
서버 액션은 form.action 이나 formAction에서만 사용할 수 있는 것은 아니다. useTranstion에서 제공하는 startTransition에서도 서버 액션을 활용할 수 있다.

#### useTranstion을 사용하면 얻을 수 있는 장점
- 이전과 동일한 로직을 구현하면서도 page 단위의 loading.jsx를 사용하지 않아도 된다.
- isPending을 활용해 startTransition으로 서버 액션이 실행됐을 때 해당 버튼을 숨기고 로딩 버튼을 노출함으로써 페이지 단위의 로딩이 아닌 컴포넌트 단위의 로딩 처리도 가능해진다.


### server mutation이 없는 작업
별도의 server mutation을 실행하지 않는다면 바로 이벤트 핸들러에 넣어도 된다.

```
export default function Page() {
    async function handleClick() {
    'use server'
    //server mutation이 필요 없는 작업
  }
return <button onClick={handleClick}> form요청 보내보기 </button>
}
```

### 서버 액션 사용 시 주의할 점

- 서버 액션은 클라이언트 컴포넌트 내에서 정의될 수 없다.
- 서버 액션을 import 하는 것 뿐만 아니라, props 형태로 서버 액션을 클라이언트 컴포넌트에 넘기는 것 또한 가능하다.

## 5부: 그 밖의 변화

이 외에도 13.0에서부터 13.4까지 업데이트 되면서 다양한 변경 사항이 추가됐다.
프로젝트 전체에서 쓸 수 있는 미들웨어가 강화됐고, SEO를 쉽게 작성할 수 있는 기능, 정적으로 내부 링크를 분석할 수 있는 기능 등 다양한 내용이 추가되었다.
