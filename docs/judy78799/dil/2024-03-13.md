# 모던 리액트 딥다이브 week2
# 2024-03-12 DIL

|주차|DIL 범위|날짜|개인 진도|
|------|---|---|---|
| 2주차 |3장, 5장|2024-03-12|336-360p|


# 05장 리액트와 상태관리 라이브러리


## 상태관리는 왜 필요한가?


### 웹 애플리케이션의 상태: 
- 어떠한 의미를 지닌 값. 
- 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미함.


### 웹 서비스에서 점차 다양한 기능이 제공됨에 따라 "tearing"을 어떻게 방지할 것인가?


## 리액트 상태관리의 역사

**당시 웹 개발 상황: 웹 애플리케이션이 비대해지고 상태(데이터)도 많아짐에 따라,
어디서 어떤 일이 일어나서 이 상태가 변했는지 이해하기 매우 어려웠음.

이 문제의 원인을 '양방향 데이터 바인딩'으로 봄.
: 뷰가 모델 변경 가능, 모델도 뷰 변경이 가능 -> 코드의 양이 많아지고 관리가 어려워짐.


### Flux 패턴의 등장: 단방향 데이터 흐름

액션 --- 디스패쳐 --- 모델 --- 뷰


### Redux의 등장

- Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나.
- Elm(웹페이지를 선언적으로 작성하기 위한 언어.) 아키텍쳐를 도입.


#### Redux의 Elm 아키텍쳐
Flux와 마찬가지로 데이터 흐름을 세 가지로 분류.
이를 단방향으로 강제해 웹앱의 상태를 안정적으로 관리하고자 노력함.
- model: 애플리케이션의 상태.
- view: 모델을 표현하는 HTML.
- update: 모델을 수정하는 방식.


#### Redux의 한계점
props 내려주기 문제 해결했지만, 단순히 하나의 상태를 바꿀 때 해야할 일이 많다는 한계점이 존재.


### Context API와 useContext

자식 컴포넌트의 깊이가 깊어질 수록 발생하는 props가 컴포넌트를 관통해버리는 현상 극복.
=> props 상태를 넘겨주지 않더라도 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게됨.


#### React 16.3 버전 이전의 context, getChildContext()의 문제점

- 상위 컴포넌트가 렌더링되면 getChildContext()가 호출됨과 동시에, shouldComponent가 항상 true를 반환 -> 불필요한 렌더링 발생.
- getChildContext() 사용하기 위해 context를 인수로 받는 과정이 컴포넌트와 결합도가 높아짐.


#### React 16.3 버전 이후 Context API
- 원하는 값을 props로 내려주지 않아도 사용 가능해짐.
- Context API는 상태관리가 아닌 주입을 도와주는 기능.
- 렌더링을 막아주는 기능 존재X.


#### Hook의 탄생, React Query와 SWR

훅 API
- state를 매우 손쉽게 재사용 가능.


#### React Query + SWR
- API 호출에 대한 상태관리 -> 'Http요청에 특화'된 라이브러리.


#### 범용적으로 사용가능한 상태관리 라이브러리 등장 Recoil, Zustand, Jotai, Valtio
- '훅'을 활용하여 '작은 크기의 상태'를 효율적으로 관리한다.
- 별도의 라이브러리를 설치하지 않아도 됨.(애초에 리액트와의 연동을 전제로 작동)
  
=> 전역 상태관리 패러다임에서 벗어나 <br>
개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만듦.


============================================================================//


상태 관리 라이브러리는 어떻게 만들어질까?



### React 훅으로 시작하는 상태관리


#### 가장 기본 근본 useState & useReducer
여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됨.
지역 상태를 관리할 수 있는 훅.

#### useState & useReducer의 한계점

- useState를 기반으로 한 상태인 지역상태는 '해당 컴포넌트 내'에서만 유효하다.
- 훅을 사용할 때마다 컴포넌트 별로 초기화. -> 컴포넌트에 따라 서로 다른 상태를 가진다.


### 컴포넌트에 따라 서로 같은 상태(값)을 가지도록 하는 방법

#### 고안 1. useState의 상태를 바깥으로 분리.
   :  useState를 리액트 클로저가 아닌 완전히 다른 곳에서 초기화되어 관리한다면,
   그 상태를 참조하는 유효한 스코프 내부에서는 해당 값을 공유해서 사용할 수 있을것임.

#### 고안 1 한계점: 컴포넌트가 리렌더링 되지 않음.


### 리렌더링 되는 조건?
- useState, useReducer의 반환값 중 두번째 인수가 어떻게든 호출되어야 함.
- 부모 함수가 리렌더링 or 해당 함수가 다시 실행 되어야 함.


#### 고안 2. useState의 인수로 컴포넌트 밖에서 선언한 state를 넘겨주는 방식으로 코드 변경.


#### 고안 2 한계점: 
- 외부에 상태가 있음에도 불구하고, 함수 컴포넌트의 렌더링을 위해 <br>
함수의 내부에 동일한 상태를 관리하는 useState가 있는 구조. -> 상태 중복 관리(비효율적 방식)
- 같은 상태를 공유하지만, 동시에 렌더링 되지 않음 이슈 발생.


### 함수 외부 상태 참조 + 렌더링이 가능한 조건?

- 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 함.
- 외부 상태를 사용하는 컴포넌트는 // 상태의 변화를 알아챌 수 있어야 함 + 상태가 변화할 때마다 리렌더링이 일어나야 함.
- 상태가 원시값이 아닌 객체인 경우, 내가 감지하는 값 변화 -> 리렌더링 발생. // 감지하지 않는 값 -> 리렌더링 발생X.


#### 컴포넌트 레벨의 지역상태를 벗어나는 새로운 상태관리 코드.

상태 'store' + 값 변경을 알리는 callback 함수 + subscribe 함수(해당 callback 등록하는 역할) 필요.


  







  





  


