# 모던 리액트 딥다이브 week6
# 2024-04-16 DIL

|주차|DIL 범위|날짜|개인 진도|
|------|---|---|---|
| 6주차 |12장, 13장|2024-04-16|782-797p|

# 12장 모든 웹 개발자가 가져야 할 핵심 웹 지표

## 최대 콘텐츠풀 페인트는 페이지 로딩에 따라 변화하는 지표다. 변화하는 과정을 살펴보자.

1. 최초에 노출된 헤더가 최대 콘텐츠풀 페인트가 된다.
2. 헤더보다 큰 영역을 가지고 있는 바둑판 메뉴로 최대 콘텐츠풀 페인트가 바뀐다.
3. 콘텐츠가 로딩되면서 최대 콘텐츠풀 페인트가 가운데 사진 영역으로 바뀐다.
4. 이미지 로딩이 마침내 끝나면서 최대 콘텐츠풀 페인트 지표가 기록된다.

### 좋은 점수 판단기준

![image](https://github.com/monthly-cs/2024-03-modern-react-deep-dive/assets/116958681/c6575ed8-5f20-427d-8e4a-e2f18f8ed51f)

좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다.

### 개선 방안

#### 최대 콘텐츠풀 예상 영역에 이미지가 아닌 문자열을 넣는다.
  > 추가적인 리소스 다운로드가 필요한 이미지보다 텍스트 노출이 춸씬 더 빠르다.
#### 이미지는 어떻게 불러올 것인가?

![image](https://github.com/monthly-cs/2024-03-modern-react-deep-dive/assets/116958681/fdfaede6-7267-49b1-989f-2077c1aec99b)

img, svg, video, css 4가지 코드를 브라우저에서 실행했을 때 브라우저에서 완성된 순서를 시간 단위로 본 그래프이다. <br>
img와 video태그의 예제 코드가 상대적으로 빠르게 완성된 것을 알 수 있다.

- **img**: 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다. img 내부의 리소스는 HTML 파싱이 완료되지 않더라도 프리로드 스캐너가 병렬적으로 리소스를 다운로드한다. 최대 콘텐츠 풀 페인트 방법에 적절한 방법.
- **svg 내부의 img**:
  > 크롬 102 버전: img가 미처 로딩되지 않고 svg만 로딩된 시점에 이미 최대 콘텐츠풀 페인트가 완료된 것으로 간주한다.
  > 크롬 102 이후 버전: svg 내부의 img가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않은 것으로 간주한다.
  > img와 다른 점: 모든 리소스를 다 불러온 이후에 이미지를 불러온다: svg 내부의 img는 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않는다.// 사용 지양
- **video의 poster**: 프리로드 스캐너에 의해 조기에 발견되어 img와 같은 성능을 나타낸다.
  > 향후 poster가 없는 video의 경우 video를 실제로 로딩해 첫번째 프레임을 해당 poster 리소스로 대체할 예정이기 때문에 poster를 반드시 넣어주는 것이 좋다. 
- **background-image**: 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문에 CSS에 있는 리소스는 항상 느리다.// 사용 지양

### 그 밖에 조심해야 할 사항
- **이미지 무손실 압축**: 가능한 한 무손실 형식으로 압축할 것이 좋다.
- **loading=lazy 주의**: 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로, 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않음.
- **fadein과 같은 각종 애니메이션**: 이미지가 애니메이션과 같이 처리되면 최대 콘텐츠풀 페인트도 그 만큼 늦어진다.
- **클라이언트에서 빌드하지 말 것**: 리액트 코드를 파싱하고 읽어서 API 요청을 보내고, 응답을 받는 만큼 늦어짐.
- **최대 콘텐츠 풀 리소스는 직접 호스팅**: 가능하다면 같은 도메인에서 직접 호스팅 하는 것이 좋다.(새로운 출처의 경우 네트워크 커넥션부터 다시 수행해야 하기 때문)

## 최초 입력 지연(FID: First Input Delay)

"사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 있는지 측정하는 지표"
화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미한다.

### 정의
> 사용자가 페이지와 처음 상호 작용할 때(ex.링크 클릭, 버튼 탭 등) 부터 해당 상호작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정한다.

#### 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어줘야 사용자에게 빠른 반응성을 보장할 수 있다.
대부분 해당 입력을 처리해야 하는 브라우저의 메인 스레드에서는
무언가 대규모 렌더링이 일어나고 있거나, 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문에 웹사이트 내부가 늦어지게 된다.

#### 사용자의 입력: 다양한 이벤트 중에서도 반응성에 해당하는 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업에 초점을 맞추고 측정한다.

### 구글의 사용자 경험 'RAIL'

- Response: 사용자 입력에 대한 반응 속도 50ms 미만으로 이벤트 처리할 것. -> 최초 입력 지연
- Animation: 애니메이션 각 프레임을 10ms 이하로 생성할 것.
- Idle: 유휴 시간을 극대화해 페이직 50ms 이내에 사용자 입력에 응답하도록 할 것.
- Load: 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것.


### 기준 점수

- 좋은 점수의 기준은 100ms 이내로 응답이 와야 한다.
- 300ms을 기준으로 이내는 보통, 이후는 나쁨으로 처리된다.

### 개선 방안

최초 입력 지연에 가장 큰 영향을 미치는 메인 스레드에 이벤트를 실행할 여유를 줘야 한다.

#### 실행에 오래 걸리는 긴 작업을 분리

긴 작업이란: 메인스레드를 오래 점유하는, 실행을 완료하는데 오래 걸리는 작업을 의미함.
만약 긴 작업의 경우 웹페이지 전반에 악영향을 미치기 때문에 몇가지 대안을 연구해야 한다.

#### 몇가지 대안
- 꼭 웹페이지에서 해야 하는 작업인가? 아니라면 서버로 옮겨서 처리하자.
> 웹페이지의 성능 미리 예측해보는 방법: 크롬 개발자 도구의 성능 탭에서 CPU를 선택하면 의도적으로 성능을 떨어뜨릴 수 있다. 
- 긴 작업을 여러 개로 분리하자.(웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오자)
  > 하나의 긴 작업이 메인 스레드를 점유할 수록 사용자는 페이지에서 응답을 받지 못하고 있을 가능성이 크다. (크롬의 경우 50ms 이상 긴작업으로 간주)
  > 당장의 로딩에 필요하지 않은 리소스는 리액트의 Suspense와 Lazy, 훅은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다.
  
  
#### 자바스크립트 코드 최소화

번들러가 코드를 만드는 과정에서 필요없는 코드를 제거해 준다고 할지라도 사용되지 않는 필요 없는 코드가 존재할 수 있다.
코드를 크롬 개발자 도구를 통해 확인할 수 있다.

폴리필: 브라우저에서 지원하지 않는 메서드를 사용하기 위해서는 웹페이지에서 다음과 같은 폴리필이 필요하다.
한 메서드에 들어가는 폴리필의 크기는 제법 크다. 

#### 폴리필을 집어 넣기 전에 확인해 봐야 하는 것

- 폴리필이 필요한 환경인가?: 만약 인터넷 익스플로러 11과 같은 구형 브라우저 환경이 아니라면 대부분 폴리필을 집어넣을 필요가 없다.
- 꼭 필요한 폴리필인가?: 애플리케이션의 여러 곳에서 자주 사용되는 코드인지 확인해보자.


#### 타사 자바스크립트 코드 실행의 지연

타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아닐 가능성이 크다. 스크립트 태그의 async, defer를 이용해 지연불러오기를 하는 것이 좋다.
- defer: 스크립트에 defer 속성이 있다면 먼저 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드한다.
- async: 스크립트에 async 속성이 있다면 마찬가지로 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드 한다.
- 둘 다 없는 경우: 스크립트를 만나는 순간 다운로드가 우선되며, 다운로드가 완료되면 코드 실행이 우선된다.

스크립트는 async, defer로 갈 수록 실행은 뒤로 미뤄지지만 성능은 좋아진다. 가능하면 async를 더 가능하다면 defer로 지연하는 것이 좋다.
