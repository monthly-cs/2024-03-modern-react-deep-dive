# 모던 리액트 딥다이브 week6
# 2024-04-08 DIL

|주차|DIL 범위|날짜|개인 진도|
|------|---|---|---|
| 6주차 |10장, 11장|2024-04-08|655-687p|


# 리액트 17과 18의 변경 사항 살펴보기

리액트를 사용하고 있는 사이트들은 대부분 16버전을 많이 사용한다. (에어비엔비, 넷플릭스 등)
하지만 이러한 사실이 리액트 16버전으로 서비스하는 것이 충분하기 때문에 17,18 버전을 이해할 필요가 없다는 의미가 아니다.
최신 버전은 더 나은 기능을, 더 가볍고 빠르게 제공하는데 초점을 맞추고 있다.

## 리액트 17버전 살펴보기

- 기존에 사용하던 코드의 수정이 필요한 변경 사항을 최소화 했다.
- 16에서 17 버전으로 버전 업 하는 것은 큰 부담 없이 진행될 수 있는 작업이다. by 리액트 팀.
- 점진적인 업그레이드가 가능하다. 일부 트리와 컴포넌트에 대해서 버전 업이 가능하다.

### 2개의 리액트 버전이 공존하는 방법

- 리액트 17 애플리케이션은 내부에서 리액트 16을 게으르게 불러온다.
- 불러오는 과정에서 리액트 16을 위한 별도의 루트 요소를 만들고,
- 여기에 불러온 리액트 16 모듈을 렌더링 한다.

리액트 16,17 둘 다 지원하는 컴포넌트나 훅이라면 버전이 다른 두 리액트에서도 무리없이 사용이 가능하다.
※ 한꺼번에 업그레이드가 불가능한 상태(애플리케이션을 한꺼번에 새로운 버전으로 업그레이드가 힘든 경우)에서의 차선책으로 추천하는 방법이다.

![image](https://github.com/monthly-cs/2024-03-modern-react-deep-dive/assets/116958681/930e6840-1cfd-474e-8f8f-eca7b2011f31)

### 이벤트 위임이란?

리액트는 이벤트 핸들러를 추가한 '각각의 DOM 요소'에 부탁하는 것이 아닌,
이벤트를 '상위 컴포넌트'에만 붙이는 것을 의미한다.
16 버전에서는 모두 document에서 수행되었지만 17버전 부터는 리액트 컴포넌트 최상단 트리(루트) 요소로 바뀌었다.

각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되므로, 이벤트 버블링으로 인한 혼선을 방지할 수 있다.
다른 라이브러리(jQuery) 뿐만 아니라 다른 버전의 리액트가 혼재되어 있는 상황인 경우에도 동일한 문제가 발생할 수 있다.

### 새로운 JSX transform / 더 이상 import React from 'react' 필요없다./

- 바벨이나 타입 스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 필요한데,
- 해당 과정이 개발자에게  보이지 않는 리액트 단에서 처리되고 있었다.
- 16 버전까지는 JSX 변환을 사용하기 위해 import React from 'react'가 필요했다면,
- 17 버전부터는 바벨과 협력하여 import 구문 없이도 JSX 변환이 가능해졌다.

#### 리액트 17 버전 import 구문이 없어져서 좋은점

- import React from 'react'을 따로 입력해줄 필요가 없다.
- 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있다.
- 컴포넌트 작성을 간결하게 한다.
- 리액트 내부 코드를 살펴보면 jsx의 내부 로직이 간결하다는 것을 알 수 있다.

따라서 특별한 이유가 없다면 import React를 지우고 tsconfig.json의 jsx를 react-jsx등으로 변경할 것.

## 그 밖의 주요 변경사항

### 이벤트 풀링제거

### 이벤트 풀링이 나타나게 된 배경

과거 리액트 16에서는 이벤트를 처리하기 위한 SyntheticEvent가 있었음.
SyntheticEvent: 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체.
SyntheticEvent를 사용하면서 ,
이벤트가 발생할 때마다 이벤트를 새로 만들고, 메모리 할당 작업이 일어나고 
메모리 누수를 방지하기 위해 만든 이벤트를 주기적으로 해제해야 하는 번거로움이 있었음.

#### 이벤트 풀링 시스템
1. 이벤트 핸들러가 이벤트를 발생시킴
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져옴.
3. 해당 이벤트 정보를 '합성 이벤트 객체'에 넣어줌.
4. 유저가 지정한 이벤트 리스너가 실행됨.
5. 이벤트 객체가 초기화 되고 다시 이벤트 풀로 돌아감.

마지막 5번, 이벤트가 종료되자마자 다시 초기화 하는 방식은 사용 하는 쪽에는 직관적이지 않다.

## 삭제된 이유

- 비동기 코드로 이벤트 핸들러에 접근하기 위해서는 이러한 방식으로 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점.
- 모던 브라우저에서는 이와 같은 방식이 성능 향상에 도움이 되지 않음.
- 모던 브라우저에서 이러한 이벤트 처리에 대한 성능이 많이 개선되었기 때문에 이벤트 풀링이 퇴색하게 되었음.

## useEffect 클린업 함수의 비동기 실행

리액트 16까지는 동기적으로 처리됨.
클린업 함수가 완료되기 전까지는 다른 작업을 방해하여 불필요한 성능저하로 이어지는 문제가 존재.
리액트 17 버전 부터 화면이 완전히 업데이트 된 후에 비동기적으로 실행되는 것으로 바뀜.

## 리액트 18버전 살펴보기

### 새로 추가 된 훅 살펴보기
## useId
- 컴포넌트 별로 유니크한 값을 생성하는 훅.
- 클라이언트와 서버 간에 동일한 값이 생성되어 하이드레이션 이슈가 발생하지 않는다.
- 같은 컴포넌트임에도 인스턴스가 다르면 다른 랜덤한 값을 만들어낸다.
- useId가 생성하는 값은 :로 감싸져 있다. / CSS 선택자나 querySelector에서 작동하지 않도록 하기 위한 것이다.

## useTranstion 

- 리액트 18 변경 사항의 핵심 중 하나인 '동시성'을 다룰 수 있는 새로운 훅이다.
  > 느린 렌더링 과정에서 로딩 화면을 보여주거나 지금 진행중인 렌더링을 버리고 새로운 상태 값으로 다시 렌더링이 가능하다.
- UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅이다.
- 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 미룰 수 있다.
- 사용자에게 조금 더 나은 사용자 경험을 제공할 수 있다.

## useDeferredValue

- 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.
- 디바운스와 달리 고정된 지연 시간 없이 첫번째 렌더링이 완료된 이후에 useDeferredValue로 지연된 렌더링을 수행한다.
- 지연된 렌더링은 중단될 수 있으며, 사용자의 인터렉션을 차단하지 않는다.

### useDeferredValue 와 useTranstion의 차이점

- useTranstion: state 값을 업데이트하는 함수를 감싸서 사용한다.
- useDeferredValue state 값 자체만을 감싸서 사용한다.

### 지연된 렌더링을 한다는 점에서는 모두 동일하기 때문에 상황에 맞는 방법을 선택하자.

- 낮은 우선순위로 처리해야할 작업에 대해 직접적으로 상태를 업데이트 할 수 있는 코드에 접근할 수 있다: useTranstion
- 컴포넌트의 props와 같이 상태 업데이트에 관여할 수 없고 오로지 값만 받아야 하는 상황: useDeferredValue
