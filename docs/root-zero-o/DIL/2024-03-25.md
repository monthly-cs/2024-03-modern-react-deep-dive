### 2024-03-25

- 공부 범위 : 4. 서버 사이드 렌더링(~ 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기)
- 공부 시간 : 출근 전 8:30 ~ 9:00, 퇴근 후 18:00 ~ 19:00

<br/>
<br/>

# 4. 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

### 싱글 페이지 애플리케이션

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 JS에 의존하는 방식
- 최초 첫 페이지에서 데이터를 모두 불러온 뒤, 페이지 전환을 위한 모든 작업이 JS와 브라우저의 `history.pushState`와 `history.replaceState`로 이뤄진다.
- 페이지를 불러온 이후 하나의 페이지에서 모든 작업을 처리한다.
- `<body/>` 내부에 아무런 내용이 없고, 렌더링에 필요한 모든 내용을 JS 코드로 삽입한 이후 렌더링한다.
- 단점 : 최초 로딩해야 할 JS 리소스가 커진다.
- 장점 : 한 번 로딩된 후 리소스를 받아올 일이 적기 때문에 사용자에게 좋은 UI/UX를 제공한다.
- 전통적 방식의 애플리케이션
  - 페이지 전환 발생 시 새로운 HTML 페이지를 다운로드해 파싱한다.
  - 처음부터 새로 그려야하기 때문에 페이지가 전환될 때 부자연스러울 수 있다.

#### 싱글 페이지 렌더링 방식의 등장

- CommonJS, AMD(Asynchronous Module Definition)
  - JS가 서서히 다양한 작업을 수행하게 되면서 JS를 모듈화하는 방안이 논의되며 등장했다.
- Backbone.js, AngularJS. Knockout.js
  - JS 수준에서 MVx 프레임워크 구현
  - JS의 역할과 규모가 점점 커졌다.
- 이후 React, Vue, Angular 등장하며 싱글 페이지 렌더링 방식이 인기를 얻었다.
  - 간편한 개발 경험, 시대적 요구

#### JAM 스택

기존 웹 개발은 LAMP 스택으로 구성되어 있었다.

> Linux(운영체제), Apache(서버), MySQL(데이터베이스), PHP/Python(웹 프레임워크)

- 서버 의존적인 웹 애플리케이션은 확장성이 떨어진다.(서버도 확장해야 하기 때문에 + 클라우드 개념 부족)

<br/>

새로운 프레임워크의 등장으로 JAM 스택이 등장했다.

> Javascript, API, Markup

- 프론트엔드에서 마크업(HTML, CSS)을 미리 빌드해 두고 정적으로 사용자에게 제공
- 작동이 모두 사용자의 클라이언트에서 실행되므로 서버 확장성에서 자유로워졌다.
- 이후 서버 자체도 JS로 구현하는 구조가 인기를 끌게 되었다.

<br/>

### 서버 사이드 렌더링

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식
- 웹페이지 렌더링 책임 소재가 다르다.
  - 싱글 페이지 애플리케이션 : 사용자에게 제공되는 JS번들에서 렌더링을 담당한다.
  - 서버 사이드 렌더링 : 렌더링에 필요한 작업을 모두 서버에서 수행한다. -> 비교적 안정적인 렌더링 가능
- 장점
  - 최초 페이지 진입이 비교적 빠르다(First Contentful Paint)
    - HTTP 요청 수행, HTML 그리는 작업 등을 서버에서 수행하는 것이 더 빠르다.
    - 서버가 사용자를 감당하지 못하고, 리소스를 확보하기 어렵다면 오히려 느릴 수 있다.
  - 메타데이터 제공이 쉽다.
    - 검색 엔진은 JS를 실행하지 않는다. -> 싱글 페이지 애플리케이션은 JS에 의존하기 때문에 불리하다.
    - 서버 사이드 렌더링은 검색 엔진에 제공할 정보를 서버에서 가공해 HTML 응답으로 제공할 수 있다.
  - 누적 레이아웃 이동(Cumulative Layout Shift)이 적다.
    - 누적 레이아웃 이동 : 페이지를 보여준 이후에 뒤늦게 HTML이 추가/삭제되어 화면이 덜컥이는 것
    - 싱글 페이지 애플리케이션 : 페이지 콘텐츠가 API에 의존하고, 응답 속도가 제각각이기 때문에 누적 레이아웃 이동이 발생할 수 있다.
    - SSR : API 요청이 완전히 완료된 이후에 완성된 페이지를 제공한다.
      - 하지만 API 요청이 모두 완료될 때까지 기다려야 하므로 최초 페이지 다운로드 속도가 느려질 수 있다.
  - 사용자의 디바이스 성능에 비교적 자유롭다.
    - 부담을 서버에 나눌 수 있기 때문
  - 보안에 좀 더 안전하다.
    - 애플리케이션의 모든 활동이 브라우저에 노출되는 위험이 있다.
    - SSR : 인증 또는 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 위협을 피할 수 있eㅏ.
- 단점
  - 소스 코드를 작성할 때 항상 서버를 고려해야 한다.
    - window에 대한 접근을 최소화해야 한다.
    - 라이브러리가 서버에 대한 고려가 되어있지 않다면 클라이언트에서만 실행되도록 해야 한다. -> 너무 많아지면 SSR의 장점을 잃는다.
  - 적절한 서버가 구축되어 있어야 한다.
  - 서비스 지연에 따른 문제가 있다.
    - 지연이 일어나면 렌더링 작업이 끝나기까지 사용자에게 어떠한 정보도 제공할 수 없다.
    - 병목 현상이 심해진다면 사용자 경험을 해치게 된다.

<br/>

### SPA와 SSR을 모두 알아야 하는 이유

- 가장 뛰어난 SPA는 가장 뛰어난 SSR 애플리케이션보다 낫다.
- 평균적인 SPA는 평균적인 SSR 애플리케이션보다 느리다.
  - 최근에는 멀티 페이지 애플리케이션에서 발생하는 라우팅 문제를 해결하는 API가 브라우저에 추가되고 있다.
    - 페인트 홀딩(Paint Holding) : 같은 출처(origin)에서 라우팅이 일어날 경우 이전 페이지 모습을 잠깐 보여주는 기법
    - back forward cache(bfcache) : 브라우저 앞으로 가기, 뒤로가기 실행 시 캐시된 페이지를 보여주는 기법
    - Shared Element Transitions : 페이지 라우팅이 일어났을 때 두 페이지에 동일 요소가 있다면 해당 콘텍스트를 유지해 부드럽게 전환되게 하는 기법
- 현대의 SSR
  - 최초 웹사이트 진입 시 : SSR 방식으로 서버에서 완성된 HTML을 제공받는다.
  - 라우팅 : 서버에서 내려받은 JS를 바탕으로 SPA처럼 작동한다.
- 두 방식을 모두 이해해야 제대로 된 웹서비스를 구축할 수 있다.

<br/>
<br/>

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

리액트는 리액트 애플리케이션을 서버에서 렌더링할 수 있는 API도 제공한다.

- Node.js와 같은 서버 환경에서만 실행할 수 있다.
- window 환경에서 실행 시 에러가 발생할 수 있다.

<br/>

### renderToString

- 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
- SSR을 구현하는 데 가장 기초적인 API

```javascript
const result = ReactDOMServer.renderToString(
  React.createElement("div", { id: "root" }, <SampleComponent />)
);
```

- useEffect같은 훅과 handleClick과 같은 이벤트 핸들러는 결과물에 포함되지 않는다.
  - 빠르게 브라우저가 렌더링할 수 있는 HTML을 제공하는 데 목적이 있다.
  - 클라이언트에서 실행되는 JS 코드를 포함시키거나 렌더링해주는 역할까지 하지는 않는다.
- 리액트의 SSR은 단순히 '최초 HTML 페이지를 빠르게 그려주는 데' 목적이 있다.
  - 인터랙션을 위해서는 별도의 JS 코드를 모두 다운로드, 파싱, 실행해야 한다.
- div#root의 속성 data-reactroot
  - 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할을 한다.
  - 이후 JS를 실행하기 위한 hydrate 함수에서 루트를 식별하는 기준점이 된다.

<br/>

### renderToStaticMarkup

- 리액트 컴포넌트를 기준으로 HTML 문자열을 만든다.
- renderToString이 루트 요소에 추가한 data-reactroot 등 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다.
- HTML의 크기를 약간이라도 줄일 수 있는 장점이 있다.

```javascript
const result = ReactDOMServer.renderToStaticMarkup(
  React.createElement("div", { id: "root" }, <SampleComponent />)
);
```

- renderToStaticMarkup의 결과물을 기반으로 hydrate를 수행하면 서버와 클라이언트 내용이 맞지 않는다는 에러가 발생한다.
  - renderToStaticMarkup은 순수한 HTML만 반환하기 때문이다.
  - 이벤트 리스너가 필요 없는 완전히 순수한 HTML을 만들 때만 사용한다.

<br/>

### renderToNodeStream

- renderToString과 결과물이 완전히 동일하지만 차이점이 있다.

  - renderToString, renderToStaticMarkup은 브라우저에서도 실행할 수 있지만, renderToNodeStream은 브라우저에서 사용할 수 없다. - 완전히 Node.js 환경에 의존한다.
    > ReactDOMServer.renderToNodeStream() : The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.
  - 결과물의 타입이 다르다.
    - renderToString : string인 문자열
    - renderToNodeStream : Node.js의 ReadableStream(utf-8로 인코딩된 바이트 스트림, 서버환경에서만 사용할 수 있다.)

- 그렇다면 어디서 필요할까?
  - 스트림 : 큰 데이터를 다룰 때 데이터를 청크로 분할해 조금씩 가져오는 방식
  - renderToString으로 생성하는 HTML의 크기가 매우 크면 Node.js가 실행되는 서버에 부담이 될 수 있다.
  - 대신 스트림을 활용하면 데이터를 청크 단위로 분리해 순차적으로 처리해 부담을 덜 수 있다.
  - 리액트 SSR 프레임워크는 모두 renderToNodeStream을 채택하고 있다.

<br/>

### renderToStaticNodeStream

- renderToNodeStream와 제공하는 결과물을 동일하나, 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.
- hydrate할 필요 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드
