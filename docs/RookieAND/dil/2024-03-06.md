# ✒️ 클로저

### ✏️ 클로저의 정의

- MDN 에서 정의한 클로저는 주변 상태(어휘적 환경)에 대한 참조와 함께 묶인(포함된) 함수의 조합이다.
- 즉, 함수가 생성되는 위치를 기준으로 주변의 Lexical Environment (어휘적 환경) 을 참조하고, 해당 환경 내부에 정의된 모든 식별자가 클로저의 대상이 된다.

```js
function makeFunc() {
  // displayName 함수 내부에서 스코프 체이닝으로 인해 해당 변수를 참조하므로, makeFunc 함수가 종료되어 실행 컨텍스트에서 사라져도 변수는 사라지지 않는다.
  const name = "Mozilla";
  function displayName() {
    // name 은 displayName 의 외부 Lexical Environment 에 위치한 name 변수를 참조한다.
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();
```

> 실행 컨텍스트 관점에서 해당 클로저가 어떻게 동작하는지를 살펴보자.

- myFunc 식별자에 `makeFunc` 함수의 실행 결과가 할당된다. Call Stack 에 `myFunc` 함수와 관련한 실행 컨텍스트가 적재된다.
- `makeFunc` 함수는 내부에서 `displayName` 함수를 선언한다. Call Stack 에 `displayName` 함수와 관련한 실행 컨텍스트가 적재된다.
- 이때 `displayName` 함수가 선언된 환경 (makeFunc 함수) 을 보면 name 변수가 있다.
- `displayName` 실행 컨텍스트 내부의 **outerEnvironmentReference** 포인터에 의해 외부 Lexical Environment 를 참조한다.
- 외부의 Lexical Environment (`makeFunc` 함수) 내 Environment Record 내부에는 name 식별자가 있고, displayName 함수 내부에서는 이를 사용한다.
- 이후 `makeFunc` 함수가 종료되고 Call Stack 에 쌓였던 실행 컨텍스트 또한 제거 된다.
- 하지만 **클로저에 의해 참조되는 변수 name 은 유효**하여 사라지지 않고, 이후 myFunc 함수를 호출할 때도 스코프 체이닝으로 접근이 가능하다.

> 클로저에 의해 사라지지 않는 변수를 뭐라고 할까?

- 함수는 자신이 선언되었을 당시의 Lexical Environment 를 참조할 수 있다.
- 그 이유는 실행 컨텍스트 내부의 outerEnvironmentReference 포인터 때문이다. (스코프 체이닝에 쓰임)
- 만약 외부의 실행 컨텍스트가 Call Stack 에서 제거되었더라도, 클로저로 인해 참조되는 변수는 사라지지 않는다. 
- 이러한 변수를 **자유 변수** 라고 한다. 해당 변수를 참조하는 함수에 더 이상 접근할 수 없지 않는 이상 계속해서 메모리에 잔존한다.


### ✏️  전역 스코프

- 전역 레벨 (Global Context) 에서 선언된 변수들의 유효 범위를 전역 스코프라고 정의한다.
- Scope Chaining 에 의해 해당 변수는 코드 어디서든 접근할 수 있다.
- 브라우저에서는 window 객체에, NodeJS 런타임 환경에서는 global 전역 객체에 전역 레벨에서 선언된 식별자들이 바인딩 된다.

```js
var global = 'global'

function hello () {
    // hello 내부에서 사용되는 global 의 경우에도 Scope Chaining 을 기반으로 전역 컨텍스트에 정의된 global 변수를 참조한다.
    console.log(global) // global
}

console.log(global) // global

```

### ✏️  함수 스코프

- JS 에서는 타 언어와 다르게 기본적으로 함수 레벨의 스코프를 기준으로 나눈다.
- 만약 함수 내부에 식별자가 정의되었다면, 해당 함수 내부가 아닌 다른 곳에서는 해당 식별자를 참조할 수 없다.

```js
function a() {
    const x = '100';
    var y = '200';
    console.log(x) // 100

    function b() {
        var x = '1000';
        console.log(x) // 1000
        console.log(y) // 200
    }
}
```

- 함수 a 내부에 선언된 x 변수에 할당된 값은 100 이고, 이는 함수 a 내부에서 유효하다.
- 함수 b 내부에 선언된 x 변수에 할당된 값은 1000 이고, 이는 함수 b 내부에서 유효하다.
- 함수 b 내부에서 쓰이는 y 변수는 스코프 체이닝으로 인해 a 함수 내부에 선언된 변수를 참조하고, 할당된 값은 200 이다.

> 블록 스코프

- ES6 에서 추가된 const, let 의 경우 중괄호 (`{}`) 를 기준으로 스코프를 할당 받는다. 이를 블록 스코프라고 한다.

```js
var a = 100;

{
    const a = 1000;
    console.log(a); // 1000
}

console.log(a); // 100
```


### ✏️ 클로저의 장점

- 특정 값의 접근을 클로저를 활용하여 제한할 수 있고, 값의 수정과 삭제에 필요한 로직을 특정하여 넘겨줄 수 있다.
- React 의 경우 State 를 클로저로 관리하며, 이를 수정할 수 있는 수단으로 setState 함수를 넘겨 클로저에 접근할 수 있도록 해준다.
- 해당 state 를 호출한 함수 컴포넌트의 실행이 종료되더라도, state 의 값은 클로저로 인해 메모리에 저장된 상태이기 때문에 리렌더링 이후에도 state 값에 접근할 수 있다.


### ✏️ 클로저의 단점

- 클로저에 의해 특정 값을 GC 에 의해 사라지는 것을 막고 이를 계속 메모리에 보관하는 것은 어느 정도의 비용을 수반한다.
- 만약 불필요한 값이 클로저에 의해 보관되고 사라지지 않는다면 이는 메모리 누수의 원인이 되며, 불필요하게 큰 메모리를 잡아먹을 수 있다.

```js 
// Closure 를 사용하지 않은 경우
const aButton = document.getElementById('a');

function heavyJob() {
    const longArr = Array.from({length: 100_000_100}, (_, i) => i);
    console.log(longArr);
}

aButton.addEventListener('click', heavyJob)

// Closure 를 사용하는 경우
const bButton = document.getElementById('b');

function heavyJobWithClosure() {
    // longArr 배열은 heavyJobWithClosure 함수가 호출되어 내부 함수가 반환될 때 참조되며, 메모리에서 사라지지 않는다.
     const longArr = Array.from({length: 100_000_100}, (_, i) => i);

     return function () {
        // 여기서 longArr 를 사용하고 있기 때문에 longArr 변수는 메모리에서 사라지지 않는다.
        console.log(longArr);
     }
}

const innerFunc = heavyJobWithClosure();

bButton.addEventListener('click', function () {
    innerFunc();
})
```

- 클로저를 사용하는 경우 이벤트가 발동되었을 때 배열이 생성되는 것이 아닌, `heavyJobWithClosure` 함수가 실행되어 `innerFunc` 에 반환된 함수가 적재될 때 생성된다.
- 따라서 실제 해당 배열이 필요한 경우 (Click 이벤트가 발동된 순간) 가 아니라 **항상 longArr 배열을 메모리에 적재해두기 때문에** 클로저를 사용하는 것이 더 비효율적이다.
